// Cloudflare Workers - Gold Price Bot
// APIs used: BrsApi.ir for gold prices, Telegram Bot API for messages
// Database: Cloudflare D1 for user tracking

const GOLD_API_URL = 'https://BrsApi.ir/Api/Market/Gold_Currency_Pro.php';

// âŒ Ø³ÛŒØ³ØªÙ… Ù…Ø¯ÛŒØ±ÛŒØª Ø®Ø·Ø§ Ùˆ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² ØªÚ©Ø±Ø§Ø±
const ERROR_COOLDOWN_MINUTES = 15; // Ù…Ø¯Øª Ø²Ù…Ø§Ù† Ø®Ø§Ù…ÙˆØ´ÛŒ Ù¾Ø³ Ø§Ø² Ø®Ø·Ø§
const ERROR_KEY_PREFIX = 'error_';
const ERROR_ATTEMPT_KEY = 'error_attempts';
const MAX_ATTEMPTS_BEFORE_COOLDOWN = 3; // ØªØ¹Ø¯Ø§Ø¯ ØªÙ„Ø§Ø´â€ŒÙ‡Ø§ÛŒ Ù…Ø¬Ø§Ø² Ù‚Ø¨Ù„ Ø§Ø² cooldown

/**
 * Parse admin IDs from comma-separated string
 * Example: "123456,789012,345678" â†’ [123456, 789012, 345678]
 */
function parseAdminIds(adminIdsString) {
    if (!adminIdsString) return [];
    return adminIdsString
        .split(',')
        .map(id => parseInt(id.trim()))
        .filter(id => !isNaN(id));
}

/**
 * Check if user is admin
 */
function isAdmin(userId, adminIds) {
    return adminIds.includes(userId);
}

/**
 * Get user state (e.g., 'main_menu', 'admin_panel')
 */
async function getUserState(kvNamespace, userId) {
    try {
        if (!kvNamespace) return 'main_menu';
        const state = await kvNamespace.get(`user_state_${userId}`);
        return state || 'main_menu';
    } catch (error) {
        console.warn('âš ï¸ Error getting user state:', error.message);
        return 'main_menu';
    }
}

/**
 * Set user state
 */
async function setUserState(kvNamespace, userId, state) {
    try {
        if (!kvNamespace) return;
        await kvNamespace.put(`user_state_${userId}`, state);
        console.log(`ğŸ‘¤ User ${userId} state changed to: ${state}`);
    } catch (error) {
        console.warn('âš ï¸ Error setting user state:', error.message);
    }
}

/**
 * Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø¢ÛŒØ§ Ø³ÛŒØ³ØªÙ… Ø¯Ø± Ø­Ø§Ù„Øª Ø®Ø§Ù…ÙˆØ´ÛŒ (cooldown) Ø§Ø³Øª
 */
async function isInErrorCooldown(kvNamespace, errorType) {
    try {
        const cooldownKey = `${ERROR_KEY_PREFIX}${errorType}_cooldown`;
        const cooldownTime = await kvNamespace.get(cooldownKey);

        if (!cooldownTime) {
            return false;
        }

        const cooldownUntil = parseInt(cooldownTime);
        const now = Date.now();

        if (now < cooldownUntil) {
            console.log(`â¸ï¸ ${errorType}: Ø¯Ø±Ø­Ø§Ù„Øª Ø®Ø§Ù…ÙˆØ´ÛŒ ØªØ§ ${new Date(cooldownUntil).toISOString()}`);
            return true;
        }

        // Cooldown Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ØŒ Ù¾Ø§Ú© Ú©Ù†
        await kvNamespace.delete(cooldownKey);
        console.log(`âœ… ${errorType}: Ø®Ø§Ù…ÙˆØ´ÛŒ ØªÙ…Ø§Ù… Ø´Ø¯ØŒ ØªÙ„Ø§Ø´ Ø¯ÙˆØ¨Ø§Ø±Ù‡`);
        return false;
    } catch (error) {
        console.error('Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø±Ø±Ø³ÛŒ cooldown:', error);
        return false;
    }
}

/**
 * Ø«Ø¨Øª Ø®Ø·Ø§ Ùˆ ÙØ¹Ø§Ù„â€ŒÚ©Ø±Ø¯Ù† cooldown - Ú©Ù…â€ŒØªØ±ÛŒÙ† KV writes Ù…Ù…Ú©Ù†
 */
async function recordError(kvNamespace, errorType, errorMessage) {
    try {
        const cooldownKey = `${ERROR_KEY_PREFIX}${errorType}_cooldown`;
        const errorCountKey = `${ERROR_KEY_PREFIX}${errorType}_count`;

        // Ø´Ù…Ø§Ø±Ø´ ØªÙ„Ø§Ø´â€ŒÙ‡Ø§ÛŒ Ù…ØªÙˆØ§Ù„ÛŒ
        const countStr = await kvNamespace.get(errorCountKey);
        const count = countStr ? parseInt(countStr) + 1 : 1;

        console.log(`âŒ ${errorType}: Ø®Ø·Ø§ #${count} - ${errorMessage}`);

        // Ø§Ú¯Ø± Ø¨ÛŒØ´ Ø§Ø² Ø­Ø¯ ØªÙ„Ø§Ø´ Ú©Ø±Ø¯Ù‡ØŒ cooldown ÙØ¹Ø§Ù„ Ú©Ù†
        if (count >= MAX_ATTEMPTS_BEFORE_COOLDOWN) {
            const cooldownUntil = Date.now() + (ERROR_COOLDOWN_MINUTES * 60 * 1000);
            // batch write: Ø´Ù…Ø§Ø±Ø´ + cooldown Ø±Ø§ Ù‡Ù…Ø²Ù…Ø§Ù† Ø°Ø®ÛŒØ±Ù‡ Ú©Ù†
            await Promise.all([
                kvNamespace.put(errorCountKey, count.toString()),
                kvNamespace.put(cooldownKey, cooldownUntil.toString())
            ]);
            console.log(`ğŸ”‡ ${errorType}: Ø®Ø§Ù…ÙˆØ´ÛŒ ÙØ¹Ø§Ù„ Ø´Ø¯ Ø¨Ø±Ø§ÛŒ ${ERROR_COOLDOWN_MINUTES} Ø¯Ù‚ÛŒÙ‚Ù‡`);
            return 'COOLDOWN_ACTIVATED';
        } else {
            // ÙÙ‚Ø· Ø´Ù…Ø§Ø±Ø´ Ø±Ùˆ Ø¢Ù¾Ø¯ÛŒØª Ú©Ù† (ÛŒÚ© write Ø¨Ù‡ Ø¬Ø§ÛŒ 2-3 writes)
            await kvNamespace.put(errorCountKey, count.toString());
        }

        return 'ERROR_RECORDED';
    } catch (error) {
        // Ø§Ú¯Ø± KV limit Ø´Ø¯ØŒ ÙÙ‚Ø· Ù„Ø§Ú¯ Ú©Ù† - Ø±ÛŒØªÙˆØ±Ù† Ù†Ø¯Ù‡ ØªØ§ webhook Ø¨Ø´Ú©Ù†Ø¯
        console.error('âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª Ø®Ø·Ø§:', error.message);
        // Ø§Ú¯Ø± Ù‚Ø¨Ù„Ø§Ù‹ Ú©ÙˆÙ„â€ŒØ¯Ø§ÙˆÙ† Ø¨ÙˆØ¯ØŒ ÙØ±Ø¶ Ú©Ù† Ø§ÛŒÙ† Ø¨Ø§Ø± Ù‡Ù… Ø§Ø³Øª
        return 'ERROR_SUPPRESSED';
    }
}

/**
 * Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† ÙˆØ¶Ø¹ÛŒØª Ø®Ø·Ø§ (Ø¨Ø¹Ø¯ Ø§Ø² Ù…ÙˆÙÙ‚ÛŒØª)
 */
async function clearErrorStatus(kvNamespace, errorType) {
    try {
        const errorCountKey = `${ERROR_KEY_PREFIX}${errorType}_count`;
        await kvNamespace.delete(errorCountKey);
        console.log(`âœ… ${errorType}: ÙˆØ¶Ø¹ÛŒØª Ø®Ø·Ø§ Ù¾Ø§Ú© Ø´Ø¯`);
    } catch (error) {
        // Ø§Ú¯Ø± Ø­ØªÛŒ delete Ù‡Ù… fail Ø´ÙˆØ¯ØŒ silent ignore Ú©Ù†
        console.warn(`âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† ÙˆØ¶Ø¹ÛŒØª: ${error.message}`);
    }
}

/**
 * Fetch currency data (USD) from API
 */
async function fetchCurrencyData(apiKey) {
    try {
        const url = new URL(GOLD_API_URL);
        url.searchParams.append('key', apiKey);
        url.searchParams.append('section', 'currency');

        const response = await fetch(url.toString());
        const data = await response.json();

        console.log('ğŸ’µ Currency API Response - successful:', data.successful);

        if (!data.successful) {
            console.error('âŒ API unsuccessful:', data.message_error);
            return null;
        }

        if (!data.currency) {
            console.error('âŒ No currency data in response');
            console.log('ğŸ“Š Available keys:', Object.keys(data));
            return null;
        }

        let usd = null;

        // Recursive search Ø¨Ø±Ø§ÛŒ USD Ø¯Ø± ØªÙ…Ø§Ù… structures
        function findUSD(obj, depth = 0) {
            if (depth > 5) return null; // Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² infinite loop

            if (!obj) return null;

            if (Array.isArray(obj)) {
                console.log(`ğŸ“Š Array with ${obj.length} items`);
                return obj.find(c => c?.symbol === 'USD' || c?.symbol === 'usd');
            }

            if (typeof obj === 'object') {
                // Ù…Ø³ØªÙ‚ÛŒÙ… Ú†Ú©
                if (obj.symbol === 'USD' || obj.symbol === 'usd') return obj;

                // Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† key
                if (obj.USD) return obj.USD;
                if (obj.usd) return obj.usd;

                // Ø¬Ø³ØªØ¬Ùˆ Ø¯Ø± properties
                for (const [key, value] of Object.entries(obj)) {
                    if (value && typeof value === 'object') {
                        if (value.symbol === 'USD' || value.symbol === 'usd') return value;
                        const found = findUSD(value, depth + 1);
                        if (found) return found;
                    }
                }
            }
            return null;
        }

        usd = findUSD(data.currency);

        if (usd) {
            console.log(`âœ… Found USD: ${usd.price}`);
            return {
                price: usd.price,
                name: usd.name || 'USD',
                date: usd.date,
                time: usd.time
            };
        }

        console.error('âŒ USD not found in currency data');
        console.log('ğŸ“‹ Full structure:', JSON.stringify(data.currency).substring(0, 500));
        return null;
    } catch (error) {
        console.error('âŒ Error fetching currency data:', error.message);
        return null;
    }
}

/**
 * Fetch all gold types from API
 */
async function fetchAllGoldTypes(apiKey) {
    try {
        const url = new URL(GOLD_API_URL);
        url.searchParams.append('key', apiKey);
        url.searchParams.append('section', 'gold');

        const response = await fetch(url.toString());
        const data = await response.json();

        console.log('API Response successful:', data.successful);

        if (data.successful && data.gold) {
            return data.gold;
        }

        console.error('âŒ Failed to fetch gold types:', data.message_error);
        return null;
    } catch (error) {
        console.error('Error fetching gold types:', error);
        return null;
    }
}

/**
 * Fetch gold price from API and compare with previous price
 */
async function fetchGoldPrice(apiKey, kvNamespace) {
    try {
        const url = new URL(GOLD_API_URL);
        url.searchParams.append('key', apiKey);
        url.searchParams.append('section', 'gold');

        const response = await fetch(url.toString());
        const data = await response.json();

        console.log('API Response successful:', data.successful);

        if (data.successful) {
            // Get gold ounce (Ø§Ù†Ø³ Ø·Ù„Ø§)
            if (data.gold && data.gold.ounce && data.gold.ounce.length > 0) {
                const goldOunce = data.gold.ounce[0];

                console.log('Gold Ounce found:', goldOunce.name);

                // Get previous price from KV
                const previousPriceStr = await kvNamespace.get('lastPrice');
                const previousPrice = previousPriceStr ? parseFloat(previousPriceStr) : null;

                console.log(`Previous price: ${previousPrice}, Current price: ${goldOunce.price}`);

                // Calculate change if we have a previous price
                let changeValue = goldOunce.change_value;
                let changePercent = goldOunce.change_percent;

                if (previousPrice !== null) {
                    changeValue = goldOunce.price - previousPrice;
                    changePercent = (changeValue / previousPrice) * 100;
                    console.log(`Calculated change: ${changeValue}, Percent: ${changePercent}%`);
                }

                // Store current price for next comparison
                await kvNamespace.put('lastPrice', goldOunce.price.toString());
                console.log(`Stored price in KV: ${goldOunce.price}`);

                return {
                    price: goldOunce.price,
                    changeValue: changeValue,
                    changePercent: changePercent,
                    date: goldOunce.date,
                    time: goldOunce.time,
                    name: goldOunce.name,
                    symbol: goldOunce.symbol,
                    unit: goldOunce.unit
                };
            } else {
                console.error('âŒ No gold ounce data found in response');
                return null;
            }
        }

        console.error('âŒ API returned unsuccessful:', data.message_error);
        return null;
    } catch (error) {
        console.error('Error fetching gold price:', error);
        return null;
    }
}

/**
 * Calculate real gold price (Ounce) considering USD rate
 * Formula: realPrice = (Ounce_Price Ã— USD_Rate) Ã· 41.47
 */
async function calculateGoldRealPrice(apiKey) {
    try {
        console.log('ğŸ” Ø´Ø±ÙˆØ¹ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‚ÛŒÙ…Øª ÙˆØ§Ù‚Ø¹ÛŒ Ø·Ù„Ø§...');

        // Fetch gold ounce price
        console.log('ğŸ“¥ Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øª Ø§Ù†Ø³ Ø¬Ù‡Ø§Ù†ÛŒ...');
        const goldData = await fetchAllGoldTypes(apiKey);

        if (!goldData) {
            console.error('âŒ Ø®Ø·Ø§: Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø·Ù„Ø§ Ø¯Ø±ÛŒØ§ÙØª Ù†Ø´Ø¯');
            return null;
        }
        console.log('âœ… Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø·Ù„Ø§ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯');

        // Fetch USD
        console.log('ğŸ“¥ Ø¯Ø±ÛŒØ§ÙØª Ù†Ø±Ø® Ø¯Ù„Ø§Ø±...');
        const usdData = await fetchCurrencyData(apiKey);

        if (!usdData) {
            console.error('âŒ Ø®Ø·Ø§: Ù†Ø±Ø® Ø¯Ù„Ø§Ø± Ø¯Ø±ÛŒØ§ÙØª Ù†Ø´Ø¯');
            return null;
        }
        console.log('âœ… Ù†Ø±Ø® Ø¯Ù„Ø§Ø± Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯:', usdData.price);

        // Find ounce (Ø§Ù†Ø³ Ø¬Ù‡Ø§Ù†ÛŒ)
        if (!goldData.ounce || !Array.isArray(goldData.ounce) || goldData.ounce.length === 0) {
            console.error('âŒ Ø§Ù†Ø³ Ø¬Ù‡Ø§Ù†ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯');
            return null;
        }

        const goldOunce = goldData.ounce[0];
        console.log('âœ… Ø§Ù†Ø³ Ø¬Ù‡Ø§Ù†ÛŒ Ù¾ÛŒØ¯Ø§ Ø´Ø¯:', goldOunce.name, '- Ù‚ÛŒÙ…Øª:', goldOunce.price);

        // Calculate: (Ounce price * USD price) / 41.47
        const realPrice = (goldOunce.price * usdData.price) / 41.47;

        console.log(`ğŸ“ Ù…Ø­Ø§Ø³Ø¨Ù‡: (${goldOunce.price} Ã— ${usdData.price}) Ã· 41.47 = ${realPrice}`);
        console.log('âœ… Ù‚ÛŒÙ…Øª ÙˆØ§Ù‚Ø¹ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø¯:', Math.round(realPrice));

        return {
            ouncePrice: goldOunce.price,
            ounceName: goldOunce.name,
            usdPrice: usdData.price,
            realPrice: realPrice,
            date: goldOunce.date,
            time: goldOunce.time
        };
    } catch (error) {
        console.error('âŒ Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‚ÛŒÙ…Øª ÙˆØ§Ù‚Ø¹ÛŒ:', error.message);
        console.error('Stack:', error.stack);
        return null;
    }
}

/**
 * Format price with Persian digits and separators
 */
function formatPersianPrice(price) {
    const englishDigits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
    const persianDigits = ['Û°', 'Û±', 'Û²', 'Û³', 'Û´', 'Ûµ', 'Û¶', 'Û·', 'Û¸', 'Û¹'];

    let priceStr = price.toString();

    // Add thousand separators
    priceStr = priceStr.replace(/\B(?=(\d{3})+(?!\d))/g, ',');

    // Convert to Persian digits
    for (let i = 0; i < englishDigits.length; i++) {
        priceStr = priceStr.replace(new RegExp(englishDigits[i], 'g'), persianDigits[i]);
    }

    return priceStr;
}

/**
 * Convert English digits to Persian
 */
function toPersianDigits(str) {
    const englishDigits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
    const persianDigits = ['Û°', 'Û±', 'Û²', 'Û³', 'Û´', 'Ûµ', 'Û¶', 'Û·', 'Û¸', 'Û¹'];

    let result = str.toString();
    for (let i = 0; i < englishDigits.length; i++) {
        result = result.replace(new RegExp(englishDigits[i], 'g'), persianDigits[i]);
    }
    return result;
}

/**
 * Format date and time to Persian format
 */
function formatPersianDateTime(shamsiDate, time) {
    // shamsiDate format: 1404/02/14, time format: 19:02
    const dateParts = shamsiDate.split('/');
    const year = toPersianDigits(dateParts[0]);
    const month = toPersianDigits(dateParts[1]);
    const day = toPersianDigits(dateParts[2]);
    const persianTime = toPersianDigits(time);

    return `${year}/${month}/${day}, ${persianTime}`;
}

/**
 * Format date to Iran timezone (Asia/Tehran)
 */
function formatToIranTime(dateString) {
    try {
        const date = new Date(dateString);
        const persianDate = date.toLocaleString('fa-IR', {
            timeZone: 'Asia/Tehran',
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });
        return persianDate;
    } catch (error) {
        console.error('Error formatting Iran time:', error);
        return dateString;
    }
}

/**
 * Build message based on price change - For Telegram Channel (with English digits, except date/time)
 */
function buildMessage(goldData) {
    const price = goldData.price;
    const changeValue = goldData.changeValue;
    const changePercent = goldData.changePercent;

    // Format price in English digits with comma separator
    const formattedPrice = price.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');

    let emoji = 'âšªï¸';
    let changeText = 'âš–ï¸ Ø¨Ø¯ÙˆÙ† ØªØºÛŒÛŒØ±';

    if (changeValue > 0) {
        emoji = 'ğŸŸ¢';
        // Use English digits for change value and percent
        const formattedChange = Math.abs(changeValue).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        const formattedPercent = changePercent.toFixed(2);
        changeText = `ğŸ“ˆ Ø§ÙØ²Ø§ÛŒØ´ : ${formattedChange}+ ${goldData.unit} (%${formattedPercent}+)`;
    } else if (changeValue < 0) {
        emoji = 'ğŸ”´';
        // Use English digits for change value and percent
        const formattedChange = Math.abs(changeValue).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        const formattedPercent = Math.abs(changePercent).toFixed(2);
        changeText = `ğŸ“‰ Ú©Ø§Ù‡Ø´ : ${formattedChange}- ${goldData.unit} (%${formattedPercent}-)`;
    }

    // Keep date and time in Persian digits
    const formattedDateTime = formatPersianDateTime(goldData.date, goldData.time);

    const message =
        `${emoji} ${goldData.name} : <b>${formattedPrice} ${goldData.unit}</b>\n\n` +
        `${changeText}\n\n` +
        `â° Ø²Ù…Ø§Ù† : ${formattedDateTime}\n\n` +
        `â— <a href="https://t.me/OunceGoldBot">ğğ®ğ§ğœğğ†ğ¨ğ¥ğğğ¨ğ­</a>`;

    return message;
}

/**
 * Build gold type message - For user requests (no change info)
 */
function buildGoldTypeMessage(goldData, isOunce = false) {
    const price = goldData.price;
    const formattedPrice = price.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    const formattedDateTime = formatPersianDateTime(goldData.date, goldData.time);

    if (isOunce) {
        // Special format for Ounce with extra spacing between lines
        const message =
            `<b>${goldData.name}</b>\n\n` +
            `ğŸ’° <b>${formattedPrice} ${goldData.unit}</b>\n\n` +
            `â° Ø¢Ø®Ø±ÛŒÙ† Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ: ${formattedDateTime}\n\n` +
            `â— <a href="https://t.me/OunceGoldBot">ğğ®ğ§ğœğğ†ğ¨ğ¥ğğğ¨ğ­</a>`;
        return message;
    } else {
        // Regular format for other types (without extra spacing)
        const message =
            `<b>${goldData.name}</b>\n` +
            `ğŸ’° <b>${formattedPrice} ${goldData.unit}</b>\n` +
            `â° Ø¢Ø®Ø±ÛŒÙ† Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ: ${formattedDateTime}`;
        return message;
    }
}

/**
 * Send message to Telegram with inline buttons
 */
async function sendTelegramMessage(botToken, chatId, message, inlineKeyboard = null) {
    try {
        const telegramApiUrl = `https://api.telegram.org/bot${botToken}/sendMessage`;

        const payload = {
            chat_id: chatId,
            text: message,
            parse_mode: 'HTML',
            disable_web_page_preview: true
        };

        if (inlineKeyboard) {
            payload.reply_markup = {
                inline_keyboard: inlineKeyboard
            };
        }

        console.log(`ğŸ“¤ Sending message to chat ID: ${chatId}`);
        console.log(`ğŸ“ Message length: ${message.length}`);

        const response = await fetch(telegramApiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(payload)
        });

        const result = await response.json();

        console.log(`ğŸ“¡ Telegram API Response:`, JSON.stringify(result));

        if (result.ok) {
            console.log('âœ… Message sent successfully');
            return true;
        } else {
            console.error(`âŒ Telegram API error: ${result.error_code} - ${result.description}`);
            return false;
        }
    } catch (error) {
        console.error('Error sending message:', error);
        return false;
    }
}

/**
 * Send message to Telegram channel
 */
async function sendPriceUpdate(botToken, channelId, message) {
    return await sendTelegramMessage(botToken, channelId, message);
}

/**
 * Handle /start command with organized keyboard
 */
async function handleStartCommand(botToken, userId, channelUsername, adminIds) {
    const welcomeMessage =
        `<b>ğŸ¤– Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯ Ø¨Ù‡ Ø±Ø¨Ø§Øª Ø§ÙÙ†Ø³ Ø·Ù„Ø§</b>\n\n` +
        `<b>Ø¯Ø³ØªØ±Ø³ÛŒ Ø³Ø±ÛŒØ¹ Ø¨Ù‡ Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ÛŒ Ø·Ù„Ø§ Ùˆ Ø³Ú©Ù‡:</b>`;

    const keyboard = [
        [
            { text: 'ğŸŒ Ø§Ù†Ø³ Ø¬Ù‡Ø§Ù†ÛŒ' }
        ],
        [
            { text: 'ğŸµ Ø³Ú©Ù‡ Ù¾Ø§Ø±Ø³ÛŒØ§Ù†' },
            { text: 'ğŸ¥‡ Ø·Ù„Ø§ Ù‡Ø§' },
            { text: 'ğŸª™ Ø³Ú©Ù‡ Ù‡Ø§' }
        ],
        [
            { text: 'ğŸ’ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø­Ø¨Ø§Ø¨ Ø·Ù„Ø§' }
        ],
        [
            { text: 'ğŸ“¢ Ø¹Ø¶ÙˆÛŒØª Ø¯Ø± Ú©Ø§Ù†Ø§Ù„' }
        ]
    ];

    // Add admin panel button if user is admin
    if (isAdmin(userId, adminIds)) {
        keyboard.push([
            { text: 'ğŸ‘¨â€ğŸ’» Ù¾Ù†Ù„ Ù…Ø¯ÛŒØ±ÛŒØª' }
        ]);
    }

    const replyMarkup = {
        keyboard: keyboard,
        resize_keyboard: true,
        one_time_keyboard: false,
        selective: false
    };

    const payload = {
        chat_id: userId,
        text: welcomeMessage,
        parse_mode: 'HTML',
        reply_markup: replyMarkup
    };

    try {
        const telegramApiUrl = `https://api.telegram.org/bot${botToken}/sendMessage`;
        const response = await fetch(telegramApiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(payload)
        });

        const result = await response.json();

        if (result.ok) {
            console.log('âœ… Welcome message with keyboard sent');
            return true;
        } else {
            console.error(`âŒ Telegram API error: ${result.error_code} - ${result.description}`);
            return false;
        }
    } catch (error) {
        console.error('Error sending welcome message:', error);
        return false;
    }
}

/**
 * Handle admin panel request - show admin menu
 */
async function showAdminPanel(botToken, userId) {
    try {
        const adminMessage =
            `<b>ğŸ‘¨â€ğŸ’» Ù¾Ù†Ù„ Ù…Ø¯ÛŒØ±ÛŒØª</b>\n\n` +
            `<b>Ø§Ù†ØªØ®Ø§Ø¨ ÛŒÚ©ÛŒ Ø§Ø² Ú¯Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ÛŒ Ø²ÛŒØ±:</b>`;

        const keyboard = [
            [
                { text: 'ğŸ“Š Ø¢Ù…Ø§Ø± Ú©Ø§Ø±Ø¨Ø±Ø§Ù†' }
            ],
            [
                { text: 'ğŸ”„ Ø¨Ø±Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†Ùˆ Ø§ØµÙ„ÛŒ' }
            ]
        ];

        const replyMarkup = {
            keyboard: keyboard,
            resize_keyboard: true,
            one_time_keyboard: false,
            selective: false
        };

        const payload = {
            chat_id: userId,
            text: adminMessage,
            parse_mode: 'HTML',
            reply_markup: replyMarkup
        };

        const telegramApiUrl = `https://api.telegram.org/bot${botToken}/sendMessage`;
        const response = await fetch(telegramApiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(payload)
        });

        const result = await response.json();

        if (result.ok) {
            console.log('âœ… Admin panel menu sent');
            return true;
        } else {
            console.error(`âŒ Telegram API error: ${result.error_code} - ${result.description}`);
            return false;
        }
    } catch (error) {
        console.error('Error showing admin panel:', error);
        return false;
    }
}

/**
 * Handle admin panel request - show statistics
 */
async function handleAdminStats(botToken, userId, db) {
    try {
        const stats = await getUserStats(db);

        if (!stats) {
            await sendTelegramMessage(botToken, userId, 'âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù…Ø§Ø±');
            return;
        }

        let adminMessage = `<b>ğŸ“Š Ø¢Ù…Ø§Ø± Ú©Ø§Ø±Ø¨Ø±Ø§Ù†</b>\n\n`;
        adminMessage += `<b>ğŸ“ˆ Ø¢Ù…Ø§Ø±Ù‡Ø§ÛŒ Ú©Ù„ÛŒ:</b>\n`;
        adminMessage += `â€¢ Ú©Ù„ Ú©Ø§Ø±Ø¨Ø±Ø§Ù†: <b>${stats.totalUsers}</b>\n`;
        adminMessage += `â€¢ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† ÙØ¹Ø§Ù„ (Û· Ø±ÙˆØ²): <b>${stats.activeUsers}</b>\n\n`;

        if (stats.topUsers && stats.topUsers.length > 0) {
            adminMessage += `<b>ğŸ† ÙØ¹Ø§Ù„â€ŒØªØ±ÛŒÙ† Ú©Ø§Ø±Ø¨Ø±Ø§Ù†:</b>\n`;
            stats.topUsers.forEach((user, index) => {
                const name = user.first_name || user.username || 'Ù†Ø§Ù…â€ŒÙ†Ø§Ø´Ù†Ø§Ø³';
                adminMessage += `${index + 1}. <b>${name}</b> - ${user.interaction_count} Ø¯Ø±Ø®ÙˆØ§Ø³Øª\n`;
            });
            adminMessage += `\n`;
        }

        if (stats.lastUser) {
            const lastUserName = stats.lastUser.first_name || stats.lastUser.username || 'Ù†Ø§Ù…â€ŒÙ†Ø§Ø´Ù†Ø§Ø³';
            const lastTime = formatToIranTime(stats.lastUser.last_interaction);
            adminMessage += `<b>â° Ø¢Ø®Ø±ÛŒÙ† Ú©Ø§Ø±Ø¨Ø±:</b>\n`;
            adminMessage += `Ù†Ø§Ù…: <b>${lastUserName}</b>\n`;
            adminMessage += `Ø²Ù…Ø§Ù†: <b>${lastTime}</b>\n`;
        }

        adminMessage += `\n<i>Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø´Ø¯Ù‡: ${formatToIranTime(new Date().toISOString())}</i>`;

        await sendTelegramMessage(botToken, userId, adminMessage);
    } catch (error) {
        console.error('Error handling admin stats:', error.message);
        await sendTelegramMessage(botToken, userId, `âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù…Ø§Ø±: ${error.message}`);
    }
}

/**
 * Process gold type button request
 */
async function processGoldTypeRequest(botToken, userId, buttonText, apiKey) {
    try {
        const allGoldData = await fetchAllGoldTypes(apiKey);

        if (!allGoldData) {
            await sendTelegramMessage(botToken, userId, 'âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø·Ù„Ø§');
            return;
        }

        let message = '';

        // Handle Ounce request
        if (buttonText.includes('Ø§Ù†Ø³')) {
            if (allGoldData.ounce && Array.isArray(allGoldData.ounce) && allGoldData.ounce.length > 0) {
                const goldData = allGoldData.ounce[0];
                const priceData = {
                    price: goldData.price,
                    changeValue: goldData.change_value || 0,
                    changePercent: goldData.change_percent || 0,
                    name: goldData.name,
                    unit: goldData.unit,
                    date: goldData.date,
                    time: goldData.time
                };
                message = buildGoldTypeMessage(priceData, true);
            }
        }
        // Handle Iran Gold types
        else if (buttonText.includes('Ø·Ù„Ø§')) {
            if (allGoldData.type && Array.isArray(allGoldData.type) && allGoldData.type.length > 0) {
                message = '<b>ğŸ¥‡ Ø·Ù„Ø§ Ù‡Ø§:</b>\n\n';
                for (const gold of allGoldData.type) {
                    const priceData = {
                        price: gold.price,
                        changeValue: gold.change_value || 0,
                        changePercent: gold.change_percent || 0,
                        name: gold.name,
                        unit: gold.unit,
                        date: gold.date,
                        time: gold.time
                    };
                    const goldMsg = buildGoldTypeMessage(priceData, false);
                    message += goldMsg + '\n\n';
                }
                message += `â— <a href="https://t.me/OunceGoldBot">ğğ®ğ§ğœğğ†ğ¨ğ¥ğğğ¨ğ­</a>`;
            }
        }
        // Handle Coins
        else if (buttonText.includes('Ø³Ú©Ù‡') && !buttonText.includes('Ù¾Ø§Ø±Ø³ÛŒØ§Ù†')) {
            if (allGoldData.coin && Array.isArray(allGoldData.coin) && allGoldData.coin.length > 0) {
                message = '<b>ğŸª™ Ø³Ú©Ù‡ Ù‡Ø§:</b>\n\n';
                for (const coin of allGoldData.coin) {
                    const priceData = {
                        price: coin.price,
                        changeValue: coin.change_value || 0,
                        changePercent: coin.change_percent || 0,
                        name: coin.name,
                        unit: coin.unit,
                        date: coin.date,
                        time: coin.time
                    };
                    const coinMsg = buildGoldTypeMessage(priceData, false);
                    message += coinMsg + '\n\n';
                }
                message += `â— <a href="https://t.me/OunceGoldBot">ğğ®ğ§ğœğğ†ğ¨ğ¥ğğğ¨ğ­</a>`;
            }
        }
        // Handle Parsian Coins
        else if (buttonText.includes('Ù¾Ø§Ø±Ø³ÛŒØ§Ù†')) {
            if (allGoldData.coin_parsian && Array.isArray(allGoldData.coin_parsian) && allGoldData.coin_parsian.length > 0) {
                message = '<b>ğŸ’ Ø³Ú©Ù‡ Ù¾Ø§Ø±Ø³ÛŒØ§Ù†:</b>\n\n';
                for (const coin of allGoldData.coin_parsian) {
                    const priceData = {
                        price: coin.price,
                        changeValue: coin.change_value || 0,
                        changePercent: coin.change_percent || 0,
                        name: coin.name,
                        unit: coin.unit,
                        date: coin.date,
                        time: coin.time
                    };
                    const coinMsg = buildGoldTypeMessage(priceData, false);
                    message += coinMsg + '\n\n';
                }
                message += `â— <a href="https://t.me/OunceGoldBot">ğğ®ğ§ğœğğ†ğ¨ğ¥ğğğ¨ğ­</a>`;
            }
        }

        if (message) {
            await sendTelegramMessage(botToken, userId, message);
        } else {
            await sendTelegramMessage(botToken, userId, 'âŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª');
        }

    } catch (error) {
        console.error('Error processing gold type request:', error);
        await sendTelegramMessage(botToken, userId, 'âŒ Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯Ø±Ø®ÙˆØ§Ø³Øª');
    }
}

/**
 * Main handler for Cloudflare Workers scheduled trigger
 */
export async function handleScheduled(event, env) {
    console.log('ğŸ¤– OunceGoldx CRON triggered');

    const botToken = env.TG_BOT_TOKEN;
    const channelId = env.TG_CHANNEL_ID;
    const apiKey = env.API_KEY;
    const kvNamespace = env.PRICE_KV;
    const db = env.DB;

    // Initialize database
    if (db) {
        await initializeDatabase(db);
    }

    // Validate environment variables
    if (!botToken) {
        console.error('âŒ Missing TG_BOT_TOKEN');
        return;
    }
    if (!channelId) {
        console.error('âŒ Missing TG_CHANNEL_ID');
        return;
    }
    if (!apiKey) {
        console.error('âŒ Missing API_KEY');
        return;
    }
    if (!kvNamespace) {
        console.error('âŒ Missing KV Namespace binding');
        return;
    }

    // ğŸ” Ø¨Ø±Ø±Ø³ÛŒ cooldown
    const inCooldown = await isInErrorCooldown(kvNamespace, 'CRON_CHANNEL');
    if (inCooldown) {
        console.log('â¸ï¸ CRON: Ù¾ÛŒØ§Ù… ÙØ±Ø³ØªØ§Ø¯Ù‡ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯ (Ø¯Ø± Ø­Ø§Ù„Øª Ø®Ø§Ù…ÙˆØ´ÛŒ)');
        return;
    }

    console.log(`ğŸ“‹ Using Channel ID: ${channelId}`);
    console.log(`ğŸ”‘ API Key exists: ${apiKey ? 'Yes' : 'No'}`);
    console.log(`ğŸ’¾ KV Namespace bound: Yes`);

    try {
        // Fetch gold price with KV comparison
        const goldData = await fetchGoldPrice(apiKey, kvNamespace);

        if (!goldData) {
            console.error('âŒ Failed to fetch gold price');
            return;
        }

        console.log(`âœ… Gold price fetched: ${goldData.price} ${goldData.unit}`);

        // Build message
        const message = buildMessage(goldData);

        // Send to Telegram
        const sent = await sendPriceUpdate(botToken, channelId, message);

        if (sent) {
            console.log(`âœ… Message sent to channel at ${new Date().toISOString()}`);
            // Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† ÙˆØ¶Ø¹ÛŒØª Ø®Ø·Ø§ Ø¨Ø¹Ø¯ Ø§Ø² Ù…ÙˆÙÙ‚ÛŒØª
            await clearErrorStatus(kvNamespace, 'CRON_CHANNEL');
        } else {
            console.error('âŒ Failed to send message to channel');
        }
    } catch (error) {
        console.error('âŒ Error in handleScheduled:', error);
    }
}

/**
 * Initialize database tables
 */
async function initializeDatabase(db) {
    try {
        // Create users table
        await db.prepare(`
            CREATE TABLE IF NOT EXISTS users (
                user_id INTEGER PRIMARY KEY,
                username TEXT,
                first_name TEXT,
                last_name TEXT,
                joined_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                last_interaction DATETIME DEFAULT CURRENT_TIMESTAMP,
                interaction_count INTEGER DEFAULT 1
            )
        `).run();

        // Create indexes
        await db.prepare(`
            CREATE INDEX IF NOT EXISTS idx_users_last_interaction ON users(last_interaction)
        `).run();

        await db.prepare(`
            CREATE INDEX IF NOT EXISTS idx_users_interaction_count ON users(interaction_count)
        `).run();

        console.log('âœ… Database initialized successfully');
    } catch (error) {
        console.error('âŒ Database initialization error:', error.message);
        console.error('Full error:', error);
    }
}

/**
 * Track/record user interaction in database
 */
async function trackUser(db, userId, firstName, username) {
    try {
        if (!db) {
            console.warn('âš ï¸ Database not available for tracking');
            return;
        }

        // Check if user exists
        const existingUser = await db.prepare(
            'SELECT user_id FROM users WHERE user_id = ?'
        ).bind(userId).first();

        if (existingUser) {
            // Update existing user
            await db.prepare(
                'UPDATE users SET last_interaction = CURRENT_TIMESTAMP, interaction_count = interaction_count + 1 WHERE user_id = ?'
            ).bind(userId).run();
            console.log(`ğŸ“Š User ${userId} interaction updated`);
        } else {
            // Insert new user (with null handling)
            await db.prepare(
                'INSERT INTO users (user_id, username, first_name, last_interaction, interaction_count) VALUES (?, ?, ?, CURRENT_TIMESTAMP, 1)'
            ).bind(userId, username || null, firstName || null).run();
            console.log(`âœ¨ New user ${userId} recorded`);
        }
    } catch (error) {
        console.error('âŒ Error tracking user:', error.message);
        console.error('User ID:', userId, 'Error details:', error);
    }
}

/**
 * Get user statistics for admin panel
 */
async function getUserStats(db) {
    try {
        if (!db) {
            console.warn('âš ï¸ Database not available');
            return {
                totalUsers: 0,
                activeUsers: 0,
                topUsers: [],
                lastUser: null
            };
        }

        // Total users
        const totalUsers = await db.prepare(
            'SELECT COUNT(*) as count FROM users'
        ).first();

        // Active users in last 7 days
        const activeUsers = await db.prepare(
            `SELECT COUNT(*) as count FROM users 
            WHERE last_interaction >= datetime('now', '-7 days')`
        ).first();

        // Top 5 most active users
        const topUsersResult = await db.prepare(
            `SELECT username, first_name, interaction_count FROM users 
            WHERE username IS NOT NULL
            ORDER BY interaction_count DESC LIMIT 5`
        ).all();

        // Last interaction
        const lastUser = await db.prepare(
            `SELECT username, first_name, last_interaction FROM users 
            WHERE username IS NOT NULL
            ORDER BY last_interaction DESC LIMIT 1`
        ).first();

        const topUsers = topUsersResult?.results || [];

        console.log(`âœ… Stats retrieved: ${totalUsers?.count || 0} total users, ${activeUsers?.count || 0} active`);

        return {
            totalUsers: totalUsers?.count || 0,
            activeUsers: activeUsers?.count || 0,
            topUsers: topUsers,
            lastUser: lastUser
        };
    } catch (error) {
        console.error('âŒ Error getting stats:', error.message);
        console.error('Stack:', error.stack);
        return {
            totalUsers: 0,
            activeUsers: 0,
            topUsers: [],
            lastUser: null
        };
    }
}

/**
 * Handle incoming Telegram webhook updates
 */
export async function handleWebhook(request, env) {
    if (request.method !== 'POST') {
        return new Response('OK', { status: 200 });
    }

    try {
        const update = await request.json();
        console.log('Webhook update received:', JSON.stringify(update));

        const botToken = env.TG_BOT_TOKEN;
        const channelUsername = env.CHANNEL_USERNAME;
        const apiKey = env.API_KEY;
        const kvNamespace = env.PRICE_KV;
        const db = env.DB;
        const adminIdsString = env.ADMIN_IDS || '';
        const adminIds = parseAdminIds(adminIdsString);

        // Initialize database
        if (db) {
            await initializeDatabase(db);
        }

        // Handle /start command
        if (update.message && update.message.text === '/start') {
            const userId = update.message.from.id;
            const firstName = update.message.from.first_name;
            const username = update.message.from.username;

            console.log(`/start command from user ${userId}`);

            // Track user
            if (db) {
                await trackUser(db, userId, firstName, username);
            }

            try {
                await handleStartCommand(botToken, userId, channelUsername, adminIds);
                await clearErrorStatus(kvNamespace, 'WEBHOOK_START');
            } catch (error) {
                console.error('Ø®Ø·Ø§ Ø¯Ø± /start:', error);
                await sendTelegramMessage(botToken, userId, 'âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù…Ù†ÙˆÛŒ Ø®ÙˆØ´â€ŒØ¢Ù…Ø¯');
            }
        }

        // Handle button text (keyboard responses)
        if (update.message && update.message.text) {
            const text = update.message.text;
            const userId = update.message.from.id;
            const firstName = update.message.from.first_name;
            const username = update.message.from.username;

            // Track user activity
            if (db) {
                await trackUser(db, userId, firstName, username);
            }

            try {
                // Get user state
                const userState = await getUserState(kvNamespace, userId);
                console.log(`ğŸ‘¤ User ${userId} state: ${userState}`);

                // ============= ADMIN PANEL STATE HANDLING =============
                if (userState === 'admin_panel') {
                    // Handle admin panel options
                    if (text.includes('Ø¢Ù…Ø§Ø±')) {
                        console.log(`ğŸ“Š Admin requested stats`);
                        await handleAdminStats(botToken, userId, db);
                        return new Response('OK', { status: 200 });
                    }

                    // Handle return to main menu
                    if (text.includes('Ø¨Ø±Ú¯Ø´Øª')) {
                        console.log(`ğŸ”„ Returning to main menu`);
                        await setUserState(kvNamespace, userId, 'main_menu');
                        await handleStartCommand(botToken, userId, channelUsername, adminIds);
                        return new Response('OK', { status: 200 });
                    }

                    // If admin is in panel but clicked something else, stay in panel
                    await showAdminPanel(botToken, userId);
                    return new Response('OK', { status: 200 });
                }

                // ============= MAIN MENU STATE HANDLING =============
                // Handle admin panel entry
                if (text.includes('Ù¾Ù†Ù„') || text.includes('Ù…Ø¯ÛŒØ±ÛŒØª')) {
                    if (!isAdmin(userId, adminIds)) {
                        console.log(`âŒ Unauthorized admin panel access: ${userId}`);
                        await sendTelegramMessage(botToken, userId, 'âŒ Ø´Ù…Ø§ Ø¯Ø³ØªØ±Ø³ÛŒ Ù†Ø¯Ø§Ø±ÛŒØ¯');
                        return new Response('OK', { status: 200 });
                    }
                    console.log(`ğŸ‘¨â€ğŸ’» Admin panel accessed by ${userId}`);
                    await setUserState(kvNamespace, userId, 'admin_panel');
                    await showAdminPanel(botToken, userId);
                    return new Response('OK', { status: 200 });
                }

                // Handle gold bubble calculation
                if (text.includes('Ù…Ø­Ø§Ø³Ø¨Ù‡') || text.includes('Ø­Ø¨Ø§Ø¨')) {
                    const inCooldown = await isInErrorCooldown(kvNamespace, `CALC_${userId}`);
                    if (inCooldown) {
                        console.log(`â¸ï¸ Ù…Ø­Ø§Ø³Ø¨Ù‡: Ú©Ø§Ø±Ø¨Ø± ${userId} Ø¯Ø± Ø­Ø§Ù„Øª Ø®Ø§Ù…ÙˆØ´ÛŒ`);
                        await sendTelegramMessage(botToken, userId, 'â¸ï¸ Ù„Ø·ÙØ§ Ú†Ù†Ø¯ Ù„Ø­Ø¸Ù‡ Ø¯ÛŒÚ¯Ø± Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯');
                        return new Response('OK', { status: 200 });
                    }

                    console.log(`Gold bubble calculation from user ${userId}`);
                    const realPriceData = await calculateGoldRealPrice(apiKey);

                    if (realPriceData) {
                        console.log(`âœ… Real price calculated: ${realPriceData.realPrice}`);
                        const formattedRealPrice = Math.round(realPriceData.realPrice).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                        const formattedOunce = Math.round(realPriceData.ouncePrice).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                        const formattedUsd = Math.round(realPriceData.usdPrice).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                        const formattedDateTime = formatPersianDateTime(realPriceData.date, realPriceData.time);

                        const bubbleMessage =
                            `<b>ğŸ’ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø­Ø¨Ø§Ø¨ Ø·Ù„Ø§</b>\n\n` +
                            `<b>Ø§Ù†Ø³ Ø¬Ù‡Ø§Ù†ÛŒ:</b> ${formattedOunce} Ø¯Ù„Ø§Ø±\n` +
                            `<b>Ù†Ø±Ø® Ø¯Ù„Ø§Ø±:</b> ${formattedUsd} Ø±ÛŒØ§Ù„\n\n` +
                            `<b>Ù‚ÛŒÙ…Øª ÙˆØ§Ù‚Ø¹ÛŒ Ø·Ù„Ø§:</b>\n` +
                            `<b>${formattedRealPrice} Ø±ÛŒØ§Ù„</b>\n\n` +
                            `â° ${formattedDateTime}\n\n` +
                            `â— <a href="https://t.me/OunceGoldBot">ğğ®ğ§ğœğğ†ğ¨ğ¥ğğğ¨ğ­</a>`;

                        await sendTelegramMessage(botToken, userId, bubbleMessage);
                        await clearErrorStatus(kvNamespace, `CALC_${userId}`);
                    } else {
                        console.error('âŒ Real price calculation failed');
                        await sendTelegramMessage(botToken, userId, 'âŒ Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‚ÛŒÙ…Øª ÙˆØ§Ù‚Ø¹ÛŒ Ø·Ù„Ø§');
                    }
                    return new Response('OK', { status: 200 });
                }

                // Check if message is a gold price request button
                if (text.includes('Ø§Ù†Ø³') || text.includes('Ø·Ù„Ø§') || text.includes('Ø³Ú©Ù‡') || text.includes('Ù¾Ø§Ø±Ø³ÛŒØ§Ù†')) {
                    const inCooldown = await isInErrorCooldown(kvNamespace, `PRICE_${userId}`);
                    if (inCooldown) {
                        console.log(`â¸ï¸ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù‚ÛŒÙ…Øª: Ú©Ø§Ø±Ø¨Ø± ${userId} Ø¯Ø± Ø­Ø§Ù„Øª Ø®Ø§Ù…ÙˆØ´ÛŒ`);
                        await sendTelegramMessage(botToken, userId, 'â¸ï¸ Ù„Ø·ÙØ§ Ú†Ù†Ø¯ Ù„Ø­Ø¸Ù‡ Ø¯ÛŒÚ¯Ø± Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯');
                        return new Response('OK', { status: 200 });
                    }

                    console.log(`Gold type request from user ${userId}: ${text}`);
                    try {
                        await processGoldTypeRequest(botToken, userId, text, apiKey);
                        await clearErrorStatus(kvNamespace, `PRICE_${userId}`);
                    } catch (error) {
                        console.error('Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù‚ÛŒÙ…Øª:', error);
                        await sendTelegramMessage(botToken, userId, 'âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§');
                    }
                }

                // Handle channel join button
                if (text.includes('ğŸ“¢') || text.includes('Ø¹Ø¶ÙˆÛŒØª')) {
                    const joinMessage = `<b>ğŸ“¢ Ø¨Ø±Ø§ÛŒ Ø¹Ø¶ÙˆÛŒØª Ø¯Ø± Ú©Ø§Ù†Ø§Ù„</b>\n\nØ¨Ø± Ø±ÙˆÛŒ Ø¯Ú©Ù…Ù‡ Ø²ÛŒØ± Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯:`;
                    const inlineKeyboard = [
                        [
                            {
                                text: 'ğŸ”— Ø¹Ø¶ÙˆÛŒØª Ø¯Ø± Ú©Ø§Ù†Ø§Ù„',
                                url: `https://t.me/${channelUsername || 'OunceGoldx'}`
                            }
                        ]
                    ];
                    await sendTelegramMessage(botToken, userId, joinMessage, inlineKeyboard);
                }
            } catch (error) {
                console.error('Ø®Ø·Ø§ÛŒ Ú©Ù„ÛŒ Ø¯Ø± webhook:', error);
            }
        }

        return new Response('OK', { status: 200 });
    } catch (error) {
        console.error('Error handling webhook:', error);
        return new Response('Error', { status: 500 });
    }
}

/**
 * API Proxy endpoint for Mini Web App (GitHub Pages)
 */
async function handleApiProxy(request, env) {
    try {
        const url = new URL(request.url);
        const section = url.searchParams.get('section');
        const history = url.searchParams.get('history');
        const symbol = url.searchParams.get('symbol');
        const apiKey = env.API_KEY;

        let proxyUrl = '';

        // Ø§Ú¯Ø± Ø¯Ø±Ø®ÙˆØ§Ø³Øª history Ø§Ø³Øª
        if (history && symbol) {
            proxyUrl = `https://BrsApi.ir/Api/Market/Gold_Currency_Pro.php?key=${apiKey}&history=${history}&symbol=${symbol}`;
            console.log(`ğŸ“¡ Proxy History Request: history=${history}, symbol=${symbol}`);
        } else {
            // Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù…Ø¹Ù…ÙˆÙ„ÛŒ
            const sectionValue = section || 'gold,currency,cryptocurrency';
            proxyUrl = `https://BrsApi.ir/Api/Market/Gold_Currency_Pro.php?key=${apiKey}&section=${sectionValue}`;
            console.log(`ğŸ“¡ Proxy Section Request: ${sectionValue}`);
        }

        // Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø§Ø² API Ø§ØµÙ„ÛŒ
        const response = await fetch(proxyUrl);
        const data = await response.json();

        console.log(`âœ… Proxy Response Status: ${data.successful ? 'Success' : 'Failed'}`);

        // Ø§Ø±Ø³Ø§Ù„ Ù¾Ø§Ø³Ø® Ø¨Ø§ CORS headers
        return new Response(JSON.stringify(data), {
            headers: {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
                'Access-Control-Allow-Headers': 'Content-Type',
                'Cache-Control': 'max-age=60' // Ú©Ø´ 1 Ø¯Ù‚ÛŒÙ‚Ù‡
            }
        });
    } catch (error) {
        console.error('âŒ Proxy Error:', error.message);
        return new Response(JSON.stringify({
            successful: false,
            message_error: 'Proxy Error: ' + error.message
        }), {
            status: 500,
            headers: {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*'
            }
        });
    }
}

/**
 * Main export for Cloudflare Workers
 */
export default {
    async fetch(request, env) {
        const url = new URL(request.url);

        // API Proxy endpoint: GET /api/prices
        if (url.pathname === '/api/prices') {
            return await handleApiProxy(request, env);
        }

        // Webhook endpoint: POST /webhook
        if (url.pathname === '/webhook' && request.method === 'POST') {
            return await handleWebhook(request, env);
        }

        // Health check endpoint
        if (url.pathname === '/health') {
            return new Response(JSON.stringify({ status: 'ok' }), {
                headers: { 'Content-Type': 'application/json' }
            });
        }

        return new Response('Not Found', { status: 404 });
    },

    async scheduled(event, env) {
        await handleScheduled(event, env);
    }
};
